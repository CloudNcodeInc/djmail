.. _usage:

==========
How to use
==========

djmail works as middleware, and the simpler way to use it, is do nothink, only send
emails as what did you do before.


Email delivery backends
-----------------------

djmail provides two backends:

* **default**: sends emails on the same process/thread or in other thread.
* **celery**: sends emails asynchronously with celery tasks.

Default
^^^^^^^

This backend works in two modes: **standard** or **async**.

The **standard** mode, works very similar as any backend of django, with exception of status tracking
and failuire scheduling.

The **async** mode, do samethink like previos but sends a email in a new thread.

Celery
^^^^^^

The celery backend uses celery async tasks to send emails and its always send asyncronous. Obviously, with
same behavior as default.

Example configuration with celery backend:

.. code-block:: python

    EMAIL_BACKEND="djmail.backends.celery.EmailBackend"
    DJMAIL_REAL_BACKEND="django.core.mail.backends.console.EmailBackend"


Email retry methods
-------------------

djmail implements two methods for deliver failed email messages:

* With operating system crond service.
* With celery periodic tasks.

If you choice is crond, you need execute this management command every N min/sec:

.. code-block:: console

    python manage.py djmail_retry_send_messages


But if you choice is celery periodic tasks, this is a possible example of a configuration:

.. code-block:: python

    from datetime import timedelta

    CELERYBEAT_SCHEDULE = {
        'djmail-retry-send-every-120-seconds': {
            'task': 'tasks.retry_send_messages',
            'schedule': timedelta(seconds=120),
        },
    }

Also, you can costumize the maximum number of retry with these settings parameter:

.. code-block:: python

    DJMAIL_MAX_RETRY_NUMBER = 5


Render emails with templates
----------------------------

djmail implements two classes for build emails from templates.

* **djmail.template_mail.TemplateMail**: low lever interface.
* **djmail.template_mail.MagicMailBuilder**: very powerful and magic interface.


TemplateMail
^^^^^^^^^^^^

The ``TemplateMail`` is a low level implementation for build emails from templates.

This is a simpler example for use it:

.. code-block:: python

    # Define a subclass of TemplateMail
    class SomeTemplateEmail(template_mail.TemplateMail):
        name = "some_email"

    # Create a instance
    email = SomeTemplateEmail()

    # Buld and sent message with specified context
    email.send("to@example.com", {"template": "context"})

Also you can obtain a native django email instance from TemplateMail instance:

.. code-block:: python

    # Create a instance
    template_email = SomeTemplateEmail()

    # Or obtain a native django email object
    email = template_email.make_email_object("to@example.com",
                                             {"template": "context"})
    email.send()


TemplateMail or a subclass, by default search these templates:

* **emails/some_email-body-html.html**
* **emails/some_email-body-text.html**
* **emails/some_email-subject.html**

.. note::

    Text version of email body is omited if template does not exists.

You can change the search pattern with some settings parameters that you
can see in :ref:`Settings <settings>` section.


MagicMailBuilder
^^^^^^^^^^^^^^^^

This is a more powerful method for building messages from templates. It delegates a email
building to a TemplateMail buit exposes more easy and dynamic api.

This example represents the same behavior as previos example:

.. code-block:: python

    # Create MagicMailBuilder instance
    mails = template_mail.MagicMailBuilder()

    # Create a native email object.
    # NOTE: The method name represents a email name.
    email = mails.some_email("to@example.com", {"template": "context"})
    email.send()


Additionally, instead of receiver email address you can pass a django model
instance that represents a user:

.. code-block:: python

    class MyUser(models.Model):
        email = models.CharField(max_length=200)
        lang = models.CharField(max_length=200, default="es")
        # [...]

    user = MyUser.objects.get(pk=1)
    email = mails.some_email(user, {"template": "context"})


If you user class has email/lang field with other names, you can customize it
with some parameters to a constructor of MagicMailBuilder:

I18n
^^^^

Both previous api's implements i18n for rendering email body and subject. For activate a
specific languate you must pass ``lang`` attribute on a context parameter.

Example:

.. code-block:: python

    email = mails.some_email("to@example.com",
                             {"template": "context", "lang": "es"})

Priority
^^^^^^^^

The dynamic methods generated by **MagicMailBuilder**, accepts **priority** as optional
keyword argument (by default with 50 as priority value)-

.. note::

   Email objects with low priority are not sent immediately, but are nevertheless sending
   are delayed until the next scheduled delivery process (with cron or celery).


.. code-block:: python

    email = mails.some_email("to@example.com", {"template": "context"},
                             priority=100)
